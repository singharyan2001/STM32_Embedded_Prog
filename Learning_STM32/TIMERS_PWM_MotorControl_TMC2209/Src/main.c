/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <string.h>
#include <stdio.h>

#include "STM32F411xx.h"
#include "GPIO_Driver.h"
#include "GPTimer_Driver.h"
#include "SPI_Driver.h"
#include "SYSTICK_Driver.h"
#include "NVIC.h"


#define SYSTEM_FREQUENCY	16000000
#define TIMER_FREQUENCY		1000

#define BUFFER_SIZE		12

volatile uint8_t transmit_flag = 0;

void BUTTON_GPIO_INIT(void);

void motor_control_init(void);

void motor_control_execute(void);

//extern void initialise_monitor_handles(void);


int main(void)
{
	/* functions to run for OpenOCD Debugging */
	//initialise_monitor_handles();

	/*------------------------------------------*/
	printf("SWV printf Debugging Initialized\n");

	TIMx_Delay_ms_Init(TIM5);

	BUTTON_GPIO_INIT(); //Commented when device is in slave mode

	//Initialize Motor control configuration
	motor_control_init();

	//Set Motor driver Mode
	GPIO_SetPin(GPIOA, GPIO_PIN_2);		//HIGH
	GPIO_SetPin(GPIOA, GPIO_PIN_3);		//HIGH

	//Enable motor driver
	GPIO_ResetPin(GPIOA, GPIO_PIN_1);		//ENABLED (LOW)
	TIMx_Delay_ms(TIM5, 10);
	
	//Set Motor Driver direction
	GPIO_SetPin(GPIOA, GPIO_PIN_4);
	TIMx_Delay_ms(TIM5, 10);
	
	/* Loop forever */
	/*Master flag loop code*/
	for(;;){
		while(transmit_flag == 1){
			transmit_flag = 0;
			motor_control_execute();
		}
		TIMx_Delay_ms(TIM5, 100);	//100ms
	}
}

/* Motor Control function definitions*/
void motor_control_init(void){
	//Basic Initializations
	GPIOx_Handle_t MotorGPIO_handle;
	TIMx_Config_t PA5_TimerConfigs;
	TIMx_PWMConfig_t PA5_MotorControlConfigs;
	memset(&MotorGPIO_handle, 0, sizeof(GPIOx_Handle_t));
	memset(&PA5_TimerConfigs, 0, sizeof(TIMx_Config_t));
	memset(&PA5_MotorControlConfigs, 0, sizeof(TIMx_PWMConfig_t));
	
	//1. Configure GPIO pins - EN, MS1, MS2, DIR
	MotorGPIO_handle.pGPIOx_Base = GPIOA;
	MotorGPIO_handle.GPIO_PinConfig.GPIOx_PinMode = GPIO_MODE_OUTPUT;
	MotorGPIO_handle.GPIO_PinConfig.GPIOx_PinSpeed = GPIO_SPEED_LOW;
	MotorGPIO_handle.GPIO_PinConfig.GPIOx_PinOPType = GPIO_OUTPUT_PUSH_PULL;
	
	//Set Driver Enable pin
	MotorGPIO_handle.GPIO_PinConfig.GPIOx_PinNumber = GPIO_PIN_1;
	GPIOx_Init(&MotorGPIO_handle);

	//Set MS1 & MS2 pins (Mode select - Mode 3 -> 1/16)
	MotorGPIO_handle.GPIO_PinConfig.GPIOx_PinNumber = GPIO_PIN_2;
	GPIOx_Init(&MotorGPIO_handle);

	MotorGPIO_handle.GPIO_PinConfig.GPIOx_PinNumber = GPIO_PIN_3;
	GPIOx_Init(&MotorGPIO_handle);

	//Set Motor Driver Direction
	MotorGPIO_handle.GPIO_PinConfig.GPIOx_PinNumber = GPIO_PIN_4;
	GPIOx_Init(&MotorGPIO_handle);

	//2. Configure PWM GPIO Pin - STEP pin
	MotorGPIO_handle.GPIO_PinConfig.GPIOx_PinNumber = GPIO_PIN_5;
	MotorGPIO_handle.GPIO_PinConfig.GPIOx_PinSpeed = GPIO_SPEED_FAST;
	MotorGPIO_handle.GPIO_PinConfig.GPIOx_PinMode = GPIO_MODE_ALTERNATE;
	MotorGPIO_handle.GPIO_PinConfig.GPIOx_PinAltFunMode = GPIO_AFR_AF1;
	GPIOx_Init(&MotorGPIO_handle);

	//Configure the Timer peripheral
	PA5_TimerConfigs.TIMx = TIM2;
	PA5_TimerConfigs.System_frequency = SYSTEM_FREQUENCY;
	PA5_TimerConfigs.Timer_frequency = 100000;				//100KHZ
	PA5_TimerConfigs.Prescaler = TIMx_ComputePrescaler(TIM2, SYSTEM_FREQUENCY, 100000);
	PA5_TimerConfigs.delay = 10;				//100us delay
	PA5_TimerConfigs.Mode = TIM_MODE_UP_COUNTER;

	//Configure the PWM settings for the timer peripheral
	PA5_MotorControlConfigs.PWM_MODE = TIM_PWM_MODE1;
	PA5_MotorControlConfigs.PWM_Channel = PWM_CHANNEL_1;
	PA5_MotorControlConfigs.PWM_OC_Preload_Enable = ENABLE;
	PA5_MotorControlConfigs.PWM_Polarity = PWM_POLARITY_ACTIVE_HIGH;
	PA5_MotorControlConfigs.PWM_CH_Polarity = 1;	//Bit pos 1 - CC1P
	PA5_MotorControlConfigs.PWM_CH_Enable = 0;		//Bit pos 0 - CC1E
	PA5_MotorControlConfigs.PWM_DutyCycle = 50;		//50% Duty cycle

	//Initialize the PWM Hardware
	TIMx_PWM_Init(&PA5_TimerConfigs, &PA5_MotorControlConfigs);
}


void motor_control_execute(void){
	//Star execution						//DIR is currently HIGH
	TIMx_PWM_Start(TIM2);
	//Pass time
	TIMx_Delay_ms(TIM5, 8000);	//8 seconds
	//change direction
	GPIO_ResetPin(GPIOA, GPIO_PIN_4);		//DIR - LOW
	//Pass time
	TIMx_Delay_ms(TIM5, 8000);	//8 seconds
	
	//Small pause
	GPIO_SetPin(GPIOA, GPIO_PIN_4);			//DIR - HIGH
	TIMx_Delay_ms(TIM5, 10);

	//Stop execution
	TIMx_PWM_Stop(TIM2);
}




/*Input Button functions*/

void BUTTON_GPIO_INIT(void){
	//Create handle
	GPIOx_Handle_t GPIOHandle;
	memset(&GPIOHandle, 0, sizeof(GPIOHandle));	//Clear
	GPIOHandle.pGPIOx_Base = GPIOA;
	GPIOHandle.GPIO_PinConfig.GPIOx_PinNumber = GPIO_PIN_0;
	GPIOHandle.GPIO_PinConfig.GPIOx_PinMode = GPIO_MODE_INT_FALLING; //GPIO_MODE_INPUT;
	GPIOHandle.GPIO_PinConfig.GPIOx_PinPUPDControl = GPIO_PUPD_PULL_UP;
	//Initialize
	GPIOx_Init(&GPIOHandle);
	GPIO_SetPullUpDown(GPIOA, GPIO_PIN_0, GPIO_PUPD_PULL_UP);

	//IRQ Configurations
	GPIO_IRQ_INT_Config(IRQ_NO_EXTI0, ENABLE);
	GPIO_IRQ_Priority_Config(IRQ_NO_EXTI0, NVIC_IRQ_PRI_15);	//Priority no - 15
}

void EXTI0_IRQHandler(){
	//Handle debouncing
	//for(int i=0; i < 50000; i++);

	//Clear the Interrupt
	GPIO_IRQHandling(GPIO_PIN_0);

	//Raise Flag
	transmit_flag = 1;
}
