/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <string.h>
#include <stdio.h>

#include "STM32F411xx.h"
#include "GPIO_Driver.h"
#include "GPTimer_Driver.h"
#include "SPI_Driver.h"
#include "SYSTICK_Driver.h"
#include "NVIC.h"

#define SYSTEM_FREQUENCY	16000000
#define TIMER_FREQUENCY		1000

#define BUFFER_SIZE		12

//Test function
// void GPIO_Init(GPIOx_Handle_t *pGPIOxHandle);

/*
 * Exercise - Test the SPI_SendData API to send the string "hello world" and use the below configuration
 * 1. SPI2 in Master mode
 * 2. SCLK - max possible
 * 3. DFF = 0 & DFF = 1
*/

/*
 * Pinouts documented for SPI2 Peripheral being used
 * MOSI -> PB15 - CN10 : 26
 * MISO -> PB14 - CN10 : 28
 * SCK --> PB13 - CN10 : 30
 * NSS --> PB12 - CN10 : 16
*/

volatile uint8_t transmit_flag = 0;

//This configures the SPI GPIO Pins
void SPI2_GPIOInit(void);

//This configures the SPI device as master or slave
void SPI2_Init_Slave(void);

//This is an application test API for Transmit operations
void SPI_TX_TEST(char *data);

//This is an application test API for Receive operations
void SPI_RX_TEST(char *data);

//extern void initialise_monitor_handles(void);


typedef struct{
	int a;
	int b;
	int c;
}data_t;


int main(void)
{
	/* functions to run for OpenOCD Debugging */
	//initialise_monitor_handles();

	/*------------------------------------------*/
	//Create a buffer
	//char user_data[BUFFER_SIZE] = "Hello there";	  	//slave mode
	data_t data_tx = {50, 70, 80};

	data_t config_tx = {10,20,30};

	/* Creating an 11 bit RX buffer */
	//char rx_buffer[BUFFER_SIZE] = {0};  // Initialize with zeros
	data_t data_rx = {0};

	printf("SWV printf Debugging Initialized\n");

	printf("SIze of data: %d and type size: %d\n", sizeof(data_tx), sizeof(data_t));

	//Configure & Initialize SPI2 Peripheral
	SPI2_GPIOInit();

	SPI2_Init_Slave(); 			//for slave mode

	TIMx_Delay_ms_Init(TIM2);

	//Set TX buffer for the first time
	SPI_Set_TX_Buffer(SPI2, (uint8_t *)&config_tx, sizeof(data_t));
	
	SPI_SSOE_Configure(SPI2, ENABLE);
	SPI_Enable(SPI2);
	//SPI_SendData(SPI2, (uint8_t *)user_data, BUFFER_SIZE);	//Set SPI TX Buffer

	/*Slave loop code -- full duple - ,receive and transmit*/
	for(;;){
		//SPI_RX_TEST(rx_buffer);
		SPI_FullDuplex_Slave(SPI2, (uint8_t *)&data_tx, (uint8_t *)&data_rx, sizeof(data_t));
		printf("Received data: %d\n", data_rx.a);
		printf("Received data: %d\n", data_rx.b);
		printf("Received data: %d\n", data_rx.c);
		//now set next RX Buffer
		//SPI_Set_TX_Buffer(SPI2, (uint8_t *)&data_tx, sizeof(data_t));
	}
	
}



void SPI2_GPIOInit(void){
	//Create a GPIO Handle and perform configure
	GPIOx_Handle_t SPIPins;

	SPIPins.pGPIOx_Base = GPIOB;
	SPIPins.GPIO_PinConfig.GPIOx_PinMode = GPIO_MODE_ALTERNATE;
	SPIPins.GPIO_PinConfig.GPIOx_PinAltFunMode = GPIO_AFR_AF5;
	SPIPins.GPIO_PinConfig.GPIOx_PinOPType = GPIO_OUTPUT_PUSH_PULL;
	SPIPins.GPIO_PinConfig.GPIOx_PinSpeed = GPIO_SPEED_HIGH;
	SPIPins.GPIO_PinConfig.GPIOx_PinPUPDControl = GPIO_PUPD_PULL_UP;

	//Initialize MOSI Pin
	SPIPins.GPIO_PinConfig.GPIOx_PinNumber = GPIO_PIN_15;
	GPIOx_Init(&SPIPins);

	//Initialize MISO Pin
	SPIPins.GPIO_PinConfig.GPIOx_PinNumber = GPIO_PIN_14;
	GPIOx_Init(&SPIPins);

	//Initialize SCK
	SPIPins.GPIO_PinConfig.GPIOx_PinNumber = GPIO_PIN_13;
	GPIOx_Init(&SPIPins);

	//Initialize NSS
	SPIPins.GPIO_PinConfig.GPIOx_PinNumber = GPIO_PIN_12;

	//SPI Pins configured!
	GPIOx_Init(&SPIPins);
}

void SPI2_Init_Slave(void){
	//Configure and Initialize SPI2 peripheral
	SPIx_Handle_t SPI2_Handle;
	memset(&SPI2_Handle, 0, sizeof(SPIx_Handle_t));	//clear the handle before performing the operations on it.

	SPI2_Handle.pSPIx = SPI2;
	SPI2_Handle.SPIx_Config.SPI_DEVICE_MODE = SPI_DEVICE_MODE_SLAVE;
	SPI2_Handle.SPIx_Config.SPI_BUS_CONFIG = SPI_BUS_CONFIG_FULL_DUPLEX;
	//SPI2_Handle.SPIx_Config.SPI_SCLK_SPEED = SPI_BAUDRATE_DIV8;
	SPI2_Handle.SPIx_Config.SPI_DFF = SPI_DFF_8BIT;

	//Configure to Mode 0
	SPI2_Handle.SPIx_Config.SPI_CPOL = SPI_CPOL_LOW;
	SPI2_Handle.SPIx_Config.SPI_CPHA = SPI_CPHA_LOW;

	//Enable Software Slave management for NSS
	// SPI2_Handle.SPIx_Config.SPI_SSM = SPI_SSM_ENABLED;
	SPI2_Handle.SPIx_Config.SPI_SSM = SPI_SSM_DISABLED;		//Hardware Slave management enabled
	
	//Initialize SPI2 Peripheral
	SPI_Init(&SPI2_Handle);
}


void SPI_TX_TEST(char *data){
	//Configure SSI Bit
	//SPI_SSI_Configure(SPI2, ENABLE);
	//or
	/*
	 * If Hardware slave mangement is enabled, then making SSOE bit 1 will make NSS Output Enable.
	 * The NSS Pin is automatically managed by the hardware i.e. when SPE = 1, NSS will be pulled to low.
	 * and NSS Pin will be high when SPE = 0
	*/
	SPI_SSOE_Configure(SPI2, ENABLE);

	//Enable the SPI2 Peripheral
	SPI_Enable(SPI2);

	//Test SPI Send data API
	SPI_SendData(SPI2, (uint8_t *)data, BUFFER_SIZE);

	//After transmission, we close or disable the SPI Peripheral
	//Disable the SPI2 Peripheral
	SPI_Disable_blocking(SPI2);
}

void SPI_RX_TEST(char *data){
	SPI_ReceiveData(SPI2, (uint8_t *)data, BUFFER_SIZE);
	printf("RX Buffer is: %s\n", data);
	memset(&data, 0, sizeof(BUFFER_SIZE));
}

